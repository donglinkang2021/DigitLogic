# 三、时序电路设计

- 组合电路 vs. 时序电路
  - 多了一个状态分配

![image-20230610130725339](3时序电路设计.assets/image-20230610130725339.png)

① 规范化：规格说明 

② 形式化：状态表或状态图 

③ 状态分配：给状态编码 

④ 优化 

- 确定输入方程：下一状态函数 

- 确定输出方程：输出函数 

- 优化：对方程优化 

⑤ 工艺映射：将方程映射到触发器和门工艺 

⑥ 验证：验证设计正确性

## 规范化 

-  ==描述电路的时序行为== 

- 形式： 

  - 文字描述 

  - 数学描述 

  - 硬件描述语言 

  - 表格描述 

  - 方程描述 

  - 图表述 

-  序列识别器 
   - 文字描述：一个时序电路, 其能在输入序列中识别目标序列1101的出现

## 形式化

- ==状态图==或==状态表== 

- 状态：加载到电路历史输入的抽象 

- 序列识别器 

  - 文字描述：一个时序电路, 其能在输入序列中识别目标序列1101的出现 

  - 重叠情况：1101101中子序列==重叠，均需识别== 

    - ==1101==101 或 110==1101== 

    - 识别出==最后1个1==即识别出==第1个1==

  - 分析 

    - ==初始状态==, 没有任何符号识别 

    - ==增加一个状态==识别第一个符号 

    - 当有后续符号输入, 增加==新状态==来识别 

    - ==最终状态==表示输入序列被完整识别

|                         形式化状态图                         |                           流程如下                           |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
| ![image-20230610132625294](3时序电路设计.assets/image-20230610132625294.png) | ![image-20230610132639058](3时序电路设计.assets/image-20230610132639058.png) |
|              1. 初始状态A和识别第一个符号状态B               |                    2. 识别出子序列11状态C                    |
| ![image-20230610132652822](3时序电路设计.assets/image-20230610132652822.png) | ![image-20230610132707439](3时序电路设计.assets/image-20230610132707439.png) |
|                   3. 识别出子序列110状态D                    |                   4. 完整识别目标序列状态E                   |
| ![image-20230610133142331](3时序电路设计.assets/image-20230610133142331.png) | ![image-20230610133352812](3时序电路设计.assets/image-20230610133352812.png) |
|    5. 合并E和B，B的意义改为识别出第一个1/和识别出目标序列    | 6. 增加未正常识别转移弧（满足弧数为8：四个状态，每个状态有01两种弧转移，8个输出） |

- 状态表 

  - 输入：序列 

  - 状态：A, B, C, D 

  - 输出：结果

| 状态图（Mealy）                                              | 状态表                                                       |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![image-20230610133801603](3时序电路设计.assets/image-20230610133801603.png) | ![image-20230610133810789](3时序电路设计.assets/image-20230610133810789.png) |

重新理解一下Mealy和Moore：

#### Mealy 到Moore 

- 输入弧上输出改为当前状态输出 （就是将弧上的`/output`移到所指的状态中去，和`state`放在一起）

  - 当前状态输入弧上==输出一致，直接修改== 
  - 当前状态输入弧上==输出不一致，增加状态== 

    - 一个状态对应一个输出 
    - 不同状态：不同输入弧，相同输出弧

|                            Mealy                             |                            Moore                             |                            Moore                             |
| :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| ![image-20230610134222050](3时序电路设计.assets/image-20230610134222050.png) | ![image-20230610134235305](3时序电路设计.assets/image-20230610134235305.png) | ![image-20230610134249671](3时序电路设计.assets/image-20230610134249671.png) |
|            👆非常普通的Mealy型图，输出和输入有关👉             | 我们把它转换成Moore型状态图后B会多出一个状态，分别记为B0和B1，但我们又发现了👉 | 实际上B1就是在一开始得到的识别目标序列的状态E（可以看到5个状态就是10个弧） |

- Mealy到Moore 

- ==增加状态E== 

  - E意义：完整识别出目标序列 

  - Moore型具有==更多状态== 
    - Moore is more

- 形式化最终结果

| 状态图                                                       | 状态表                                                       |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![image-20230610135457623](3时序电路设计.assets/image-20230610135457623.png) | ![image-20230610135513421](3时序电路设计.assets/image-20230610135513421.png) |
| ![image-20230610134222050](3时序电路设计.assets/image-20230610134222050.png) | ![image-20230610135535267](3时序电路设计.assets/image-20230610135535267.png) |

## 状态分配

- 给状态分配唯一==二进制编码== 

  - m个状态至少需要n位二进制： $n\ge\left \lceil log_2 m \right \rceil$

  - 至多存在$2^n－m$个未使用状态 

- 分配方式 

  - 计数赋值：A(00)、B(01)、C(10)、D(11) 

  - 格雷码赋值：A(00)、B(01)、C(11)、D(10) 

  - 单热点赋值： 

    - A(0001)、B(0010)、C(0100)、D(1000) 

    - 每个状态一个触发器 

    - 需要m位长 

    - 只有1位为1

| 计数赋值                                                     | 格雷码赋值                                                   | 单热点赋值                                                   |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![image-20230610140155733](3时序电路设计.assets/image-20230610140155733.png) | ![image-20230610140219885](3时序电路设计.assets/image-20230610140219885.png) | ![image-20230610140242967](3时序电路设计.assets/image-20230610140242967.png) |

## 优化

- 确定输入方程：下一状态函数 

- 确定输出方程：输出函数 

- 优化：对方程优化 

- 工具：卡诺图

| 计数赋值                                                     | 格雷码赋值                                                   | 单热点赋值                                                   |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![image-20230610141053859](3时序电路设计.assets/image-20230610141053859.png) | ![image-20230610141114293](3时序电路设计.assets/image-20230610141114293.png) | ![image-20230610141235266](3时序电路设计.assets/image-20230610141235266.png) |
| ![image-20230610141127475](3时序电路设计.assets/image-20230610141127475.png) | ![image-20230610141140013](3时序电路设计.assets/image-20230610141140013.png) | ![image-20230610141332077](3时序电路设计.assets/image-20230610141332077.png) |

> 综上可以看出格雷码赋值效果最好

## 工艺映射

- 考虑系统启动时初始化 
  -  带有Reset的D触发器 

- 库中包含 

  - 带有Reset的D触发器 

  - ==反相器==和n-输入==与非门==， n = 2, 3, 4

| 格雷码赋值优化结果                                           | 优化结果                                                     | 映射结果                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![image-20230610142149264](3时序电路设计.assets/image-20230610142149264.png) | ![image-20230610142212196](3时序电路设计.assets/image-20230610142212196.png) | ![image-20230610143030400](3时序电路设计.assets/image-20230610143030400.png) |

## 验证

- 可通过呈现原始状态图或状态表进行验证 

  - 手工验证：对于小电路，可加载各种状态与 输入组合，验证输出和下一状态是否正确。

  - 模拟验证：输入能够检验所有状态和输入组合的序列(==越短越优==)、时钟信号，在时钟上升沿 后验证输出和下一个状态是否正确。

  - Verilog 

    - Testbench 

      - 时钟

      - 初始化 

      - 调用

| 手工验证                                                     | 模拟验证                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![image-20230610143414727](3时序电路设计.assets/image-20230610143414727.png) | ![image-20230610143448346](3时序电路设计.assets/image-20230610143448346.png) |

## 例子

| 设计如下                                                     | try yourself~                                                |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![image-20230610150035436](3时序电路设计.assets/image-20230610150035436.png) | ![image-20230610150047311](3时序电路设计.assets/image-20230610150047311.png) |
| ![image-20230610150104798](3时序电路设计.assets/image-20230610150104798.png) | ![image-20230610150117189](3时序电路设计.assets/image-20230610150117189.png) |
| ![image-20230610150130319](3时序电路设计.assets/image-20230610150130319.png) |                                                              |

